<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图像像素查看工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1a1a2e;
            color: #e6e6e6;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            color: #4cc9f0;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #9e9e9e;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .tool-section {
            flex: 1;
            min-width: 300px;
            background-color: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .viewer-section {
            flex: 2;
            min-width: 600px;
            background-color: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        h2 {
            color: #4cc9f0;
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 1px solid #2a3a5a;
            padding-bottom: 8px;
        }
        
        .file-input-area {
            border: 2px dashed #4cc9f0;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-area:hover {
            background-color: #1f2d4a;
        }
        
        #fileInput {
            display: none;
        }
        
        .file-label {
            display: block;
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #4cc9f0;
        }
        
        .file-formats {
            font-size: 0.9rem;
            color: #9e9e9e;
        }
        
        .control-group {
            margin-top: 20px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        label {
            color: #a5b4cb;
        }
        
        input[type="range"] {
            width: 70%;
            accent-color: #4cc9f0;
        }
        
        .value-display {
            background-color: #0f3460;
            padding: 5px 10px;
            border-radius: 4px;
            min-width: 60px;
            text-align: center;
            font-family: monospace;
        }
        
        button {
            background-color: #0f3460;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 500;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background-color: #1a4a8a;
        }
        
        button.active {
            background-color: #4cc9f0;
            color: #16213e;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background-color: #0f172a;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid #2a3a5a;
        }
        
        #imageCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }
        
        .pixel-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .info-box {
            background-color: #0f3460;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4cc9f0;
        }
        
        .info-title {
            font-size: 0.9rem;
            color: #a5b4cb;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-size: 1.4rem;
            font-family: monospace;
            font-weight: bold;
            color: #4cc9f0;
        }
        
        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 2px solid #2a3a5a;
            margin-top: 5px;
        }
        
        .pixel-grid {
            display: none;
            position: absolute;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }
        
        .pixel-grid.active {
            display: block;
        }
        
        .instructions {
            background-color: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9rem;
        }
        
        .instructions h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            color: #6b7280;
            font-size: 0.9rem;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        
        .zoom-level {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4cc9f0;
        }
        
        @media (max-width: 1100px) {
            .main-content {
                flex-direction: column;
            }
            
            .tool-section, .viewer-section {
                min-width: 100%;
            }
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 10px;
            color: #4cc9f0;
        }
        
        .status {
            font-size: 0.9rem;
            color: #a5b4cb;
            margin-top: 10px;
            text-align: center;
        }
        
        .error-message {
            background-color: #7c0a02;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>图像像素查看工具</h1>
            <p class="subtitle">支持PNG、JPG、JPEG、BMP、PGM等格式 | 单文件HTML应用 | 修复PGM二进制格式支持</p>
        </header>
        
        <div class="main-content">
            <section class="tool-section">
                <h2>图像控制</h2>
                
                <div class="file-input-area" id="dropArea">
                    <label for="fileInput" class="file-label">点击或拖拽上传图像</label>
                    <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.bmp,.pgm,.pnm,.pbm,.ppm">
                    <p class="file-formats">支持格式: PNG, JPG, JPEG, BMP, PGM (P2/P5), PBM, PPM</p>
                    <div class="loading" id="loadingIndicator">处理图像中...</div>
                </div>
                
                <div class="error-message" id="errorMessage"></div>
                
                <div class="control-group">
                    <div class="control-row">
                        <label for="zoomSlider">缩放级别:</label>
                        <input type="range" id="zoomSlider" min="1" max="40" value="1" step="0.5">
                        <div class="value-display"><span id="zoomValue">1.0</span>x</div>
                    </div>
                    
                    <div class="control-row">
                        <label for="gridToggle">显示像素网格:</label>
                        <button id="gridToggle" class="active">开启</button>
                    </div>
                    
                    <div class="control-row">
                        <label>图像操作:</label>
                        <div>
                            <button id="resetView">重置视图</button>
                            <button id="panMode" class="active">平移模式</button>
                            <button id="fitToScreen">适应屏幕</button>
                        </div>
                    </div>
                    
                    <div class="control-row">
                        <label>测试图像:</label>
                        <div>
                            <button id="testPng">测试PNG</button>
                            <button id="testJpg">测试JPG</button>
                            <button id="testPgmAscii">测试PGM (ASCII)</button>
                            <button id="testPgmBinary">测试PGM (二进制)</button>
                        </div>
                    </div>
                </div>
                
                <div class="status" id="statusMessage">就绪</div>
                
                <div class="instructions">
                    <h3>使用说明</h3>
                    <ul>
                        <li>上传图像或使用测试图像</li>
                        <li>使用鼠标滚轮或滑块进行缩放</li>
                        <li>在平移模式下拖拽图像移动</li>
                        <li>鼠标悬停查看像素RGB值</li>
                        <li>高缩放级别显示像素网格</li>
                        <li>支持PGM二进制格式(P5)和ASCII格式(P2)</li>
                    </ul>
                </div>
            </section>
            
            <section class="viewer-section">
                <h2>图像查看器</h2>
                
                <div class="canvas-container">
                    <canvas id="imageCanvas"></canvas>
                    <div id="pixelGrid" class="pixel-grid"></div>
                </div>
                
                <div class="pixel-info">
                    <div class="info-box">
                        <div class="info-title">鼠标坐标</div>
                        <div class="info-value" id="coordDisplay">X: 0, Y: 0</div>
                    </div>
                    
                    <div class="info-box">
                        <div class="info-title">像素颜色 (RGB)</div>
                        <div class="info-value" id="rgbDisplay">R: 0, G: 0, B: 0</div>
                        <div class="color-preview" id="colorPreview"></div>
                    </div>
                    
                    <div class="info-box">
                        <div class="info-title">图像尺寸</div>
                        <div class="info-value" id="sizeDisplay">0 × 0 像素</div>
                    </div>
                    
                    <div class="info-box">
                        <div class="info-title">缩放级别</div>
                        <div class="info-value zoom-level" id="zoomDisplay">1.0x</div>
                    </div>
                </div>
            </section>
        </div>
        
        <footer>
            <p>图像像素查看工具 | 单文件HTML应用 | 支持多种图像格式 | 修复PGM二进制格式支持</p>
        </footer>
    </div>

    <script>
        // 全局变量
        let canvas = document.getElementById('imageCanvas');
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let currentImage = null;
        
        // 视图参数
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let offsetXStart = 0;
        let offsetYStart = 0;
        let showGrid = true;
        let isPanMode = true;
        let lastImageData = null;
        
        // DOM元素
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const zoomDisplay = document.getElementById('zoomDisplay');
        const coordDisplay = document.getElementById('coordDisplay');
        const rgbDisplay = document.getElementById('rgbDisplay');
        const colorPreview = document.getElementById('colorPreview');
        const sizeDisplay = document.getElementById('sizeDisplay');
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('dropArea');
        const gridToggle = document.getElementById('gridToggle');
        const resetViewBtn = document.getElementById('resetView');
        const panModeBtn = document.getElementById('panMode');
        const fitToScreenBtn = document.getElementById('fitToScreen');
        const testPngBtn = document.getElementById('testPng');
        const testJpgBtn = document.getElementById('testJpg');
        const testPgmAsciiBtn = document.getElementById('testPgmAscii');
        const testPgmBinaryBtn = document.getElementById('testPgmBinary');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const statusMessage = document.getElementById('statusMessage');
        const errorMessage = document.getElementById('errorMessage');
        
        // PGM常量
        const PGM_MAGIC_P2 = 'P2'; // ASCII格式
        const PGM_MAGIC_P5 = 'P5'; // 二进制格式
        
        // 初始化
        function init() {
            setupCanvas();
            setupEventListeners();
            createDefaultTestImage(); // 创建默认测试图像
            updateStatus('就绪 - 使用测试图像或上传自己的图像');
        }
        
        // 设置Canvas
        function setupCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 窗口大小调整
            window.addEventListener('resize', () => {
                setupCanvas();
                drawImage();
            });
            
            // 文件上传
            fileInput.addEventListener('change', handleFileSelect);
            
            // 拖拽上传
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.backgroundColor = '#1f2d4a';
            });
            
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.backgroundColor = '';
            });
            
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.backgroundColor = '';
                
                if (e.dataTransfer.files.length) {
                    const file = e.dataTransfer.files[0];
                    loadImageFile(file);
                }
            });
            
            // 点击上传区域
            dropArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            // 缩放滑块
            zoomSlider.addEventListener('input', () => {
                scale = parseFloat(zoomSlider.value);
                zoomValue.textContent = scale.toFixed(1);
                zoomDisplay.textContent = scale.toFixed(1) + 'x';
                drawImage();
            });
            
            // 网格切换
            gridToggle.addEventListener('click', () => {
                showGrid = !showGrid;
                gridToggle.textContent = showGrid ? '开启' : '关闭';
                gridToggle.classList.toggle('active', showGrid);
                drawImage();
            });
            
            // 重置视图
            resetViewBtn.addEventListener('click', resetView);
            
            // 适应屏幕
            fitToScreenBtn.addEventListener('click', fitToScreen);
            
            // 平移模式
            panModeBtn.addEventListener('click', () => {
                isPanMode = !isPanMode;
                panModeBtn.textContent = isPanMode ? '平移模式' : '查看模式';
                panModeBtn.classList.toggle('active', isPanMode);
            });
            
            // 测试图像按钮
            testPngBtn.addEventListener('click', () => createTestImage('png'));
            testJpgBtn.addEventListener('click', () => createTestImage('jpg'));
            testPgmAsciiBtn.addEventListener('click', () => createTestPgmAscii());
            testPgmBinaryBtn.addEventListener('click', () => createTestPgmBinary());
            
            // Canvas交互
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave);
        }
        
        // 处理文件选择
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                loadImageFile(file);
            }
        }
        
        // 加载图像文件
        function loadImageFile(file) {
            const fileName = file.name.toLowerCase();
            const fileExt = fileName.split('.').pop();
            
            showLoading(true);
            clearError();
            updateStatus(`正在加载 ${file.name}...`);
            
            // 创建文件读取器
            const reader = new FileReader();
            
            // 检查是否为PGM/PBM/PPM文件
            if (fileExt === 'pgm' || fileExt === 'pbm' || fileExt === 'ppm') {
                // 对于Netpbm格式，读取为ArrayBuffer以支持二进制格式
                reader.onload = function(e) {
                    try {
                        parseNetpbmFile(e.target.result, fileName);
                    } catch (error) {
                        showError(`解析 ${fileExt.toUpperCase()} 文件时出错: ${error.message}`);
                        console.error(error);
                        showLoading(false);
                    }
                };
                
                reader.onerror = function() {
                    showError(`读取文件时出错: ${file.name}`);
                    showLoading(false);
                };
                
                reader.readAsArrayBuffer(file);
            } else {
                // 对于其他图像格式，使用标准方式加载
                reader.onload = function(e) {
                    loadStandardImage(e.target.result);
                };
                
                reader.onerror = function() {
                    showError(`读取文件时出错: ${file.name}`);
                    showLoading(false);
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // 解析Netpbm文件(PGM, PBM, PPM)
        function parseNetpbmFile(arrayBuffer, filename) {
            updateStatus(`解析 ${filename}...`);
            
            // 将ArrayBuffer转换为Uint8Array以便读取
            const dataView = new DataView(arrayBuffer);
            const uint8Array = new Uint8Array(arrayBuffer);
            
            let position = 0;
            
            // 读取魔术数字（P1-P6）
            const magicNumber = readAsciiLine(uint8Array, position);
            position = magicNumber.newPosition;
            
            // 检查支持的格式
            const supportedFormats = ['P1', 'P2', 'P3', 'P4', 'P5', 'P6'];
            if (!supportedFormats.includes(magicNumber.value)) {
                throw new Error(`不支持的Netpbm格式: ${magicNumber.value}`);
            }
            
            updateStatus(`格式: ${magicNumber.value}`);
            
            // 读取宽度和高度
            const widthResult = readNextToken(uint8Array, position);
            position = widthResult.newPosition;
            const width = parseInt(widthResult.value);
            
            const heightResult = readNextToken(uint8Array, position);
            position = heightResult.newPosition;
            const height = parseInt(heightResult.value);
            
            let maxVal = 1;
            
            // PBM (P1, P4) 没有maxVal参数
            if (magicNumber.value !== 'P1' && magicNumber.value !== 'P4') {
                const maxValResult = readNextToken(uint8Array, position);
                position = maxValResult.newPosition;
                maxVal = parseInt(maxValResult.value);
            }
            
            updateStatus(`尺寸: ${width}×${height}, 最大像素值: ${maxVal}`);
            
            // 根据格式处理像素数据
            let imageData;
            
            switch (magicNumber.value) {
                case 'P1': // ASCII 位图
                case 'P2': // ASCII 灰度图
                    imageData = parseAsciiPixels(uint8Array, position, width, height, maxVal, magicNumber.value === 'P1');
                    break;
                case 'P3': // ASCII RGB
                    imageData = parseAsciiRgbPixels(uint8Array, position, width, height, maxVal);
                    break;
                case 'P4': // 二进制位图
                    imageData = parseBinaryBitmap(uint8Array, position, width, height);
                    break;
                case 'P5': // 二进制灰度图
                    imageData = parseBinaryGrayscale(uint8Array, position, width, height, maxVal);
                    break;
                case 'P6': // 二进制 RGB
                    imageData = parseBinaryRgb(uint8Array, position, width, height, maxVal);
                    break;
                default:
                    throw new Error(`未处理的格式: ${magicNumber.value}`);
            }
            
            // 创建图像并显示
            createImageFromPixelData(imageData, width, height);
            updateStatus(`成功加载 ${filename} (${width}×${height})`);
            showLoading(false);
        }
        
        // 读取ASCII行
        function readAsciiLine(uint8Array, startPos) {
            let pos = startPos;
            let line = '';
            
            // 跳过空白字符和注释
            while (pos < uint8Array.length) {
                // 跳过空白字符
                if (uint8Array[pos] <= 32) {
                    pos++;
                    continue;
                }
                
                // 处理注释
                if (uint8Array[pos] === 35) { // '#'
                    // 跳过直到行尾
                    while (pos < uint8Array.length && uint8Array[pos] !== 10 && uint8Array[pos] !== 13) {
                        pos++;
                    }
                    continue;
                }
                
                break;
            }
            
            // 读取行
            while (pos < uint8Array.length && uint8Array[pos] !== 10 && uint8Array[pos] !== 13) {
                line += String.fromCharCode(uint8Array[pos]);
                pos++;
            }
            
            // 跳过换行符
            while (pos < uint8Array.length && (uint8Array[pos] === 10 || uint8Array[pos] === 13)) {
                pos++;
            }
            
            return { value: line, newPosition: pos };
        }
        
        // 读取下一个标记
        function readNextToken(uint8Array, startPos) {
            let pos = startPos;
            let token = '';
            
            // 跳过空白字符和注释
            while (pos < uint8Array.length) {
                // 跳过空白字符
                if (uint8Array[pos] <= 32) {
                    pos++;
                    continue;
                }
                
                // 处理注释
                if (uint8Array[pos] === 35) { // '#'
                    // 跳过直到行尾
                    while (pos < uint8Array.length && uint8Array[pos] !== 10 && uint8Array[pos] !== 13) {
                        pos++;
                    }
                    continue;
                }
                
                break;
            }
            
            // 读取标记
            while (pos < uint8Array.length && uint8Array[pos] > 32) {
                token += String.fromCharCode(uint8Array[pos]);
                pos++;
            }
            
            return { value: token, newPosition: pos };
        }
        
        // 解析ASCII像素数据（用于P1, P2）
        function parseAsciiPixels(uint8Array, startPos, width, height, maxVal, isBitmap) {
            const imageData = new Uint8ClampedArray(width * height * 4);
            let pos = startPos;
            let pixelIndex = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const tokenResult = readNextToken(uint8Array, pos);
                    pos = tokenResult.newPosition;
                    
                    let value = parseInt(tokenResult.value);
                    
                    // 对于位图，0是白色，1是黑色
                    if (isBitmap) {
                        value = value === 0 ? 0 : 255;
                        maxVal = 1; // 位图的最大值是1
                    }
                    
                    // 缩放值到0-255范围
                    const scaledValue = Math.floor((value / maxVal) * 255);
                    
                    const dataIndex = pixelIndex * 4;
                    imageData[dataIndex] = scaledValue;     // R
                    imageData[dataIndex + 1] = scaledValue; // G
                    imageData[dataIndex + 2] = scaledValue; // B
                    imageData[dataIndex + 3] = 255;         // A
                    
                    pixelIndex++;
                }
            }
            
            return imageData;
        }
        
        // 解析ASCII RGB像素数据（用于P3）
        function parseAsciiRgbPixels(uint8Array, startPos, width, height, maxVal) {
            const imageData = new Uint8ClampedArray(width * height * 4);
            let pos = startPos;
            let pixelIndex = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // 读取R, G, B三个值
                    const rResult = readNextToken(uint8Array, pos);
                    pos = rResult.newPosition;
                    const r = parseInt(rResult.value);
                    
                    const gResult = readNextToken(uint8Array, pos);
                    pos = gResult.newPosition;
                    const g = parseInt(gResult.value);
                    
                    const bResult = readNextToken(uint8Array, pos);
                    pos = bResult.newPosition;
                    const b = parseInt(bResult.value);
                    
                    // 缩放值到0-255范围
                    const scaledR = Math.floor((r / maxVal) * 255);
                    const scaledG = Math.floor((g / maxVal) * 255);
                    const scaledB = Math.floor((b / maxVal) * 255);
                    
                    const dataIndex = pixelIndex * 4;
                    imageData[dataIndex] = scaledR;         // R
                    imageData[dataIndex + 1] = scaledG;     // G
                    imageData[dataIndex + 2] = scaledB;     // B
                    imageData[dataIndex + 3] = 255;         // A
                    
                    pixelIndex++;
                }
            }
            
            return imageData;
        }
        
        // 解析二进制位图（用于P4）
        function parseBinaryBitmap(uint8Array, startPos, width, height) {
            const imageData = new Uint8ClampedArray(width * height * 4);
            let pos = startPos;
            
            // 计算每行的字节数（位图每行填充到8位的倍数）
            const rowBytes = Math.ceil(width / 8);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const byteIndex = Math.floor(x / 8);
                    const bitIndex = 7 - (x % 8); // 位图中的位顺序是从MSB到LSB
                    
                    const byte = uint8Array[pos + byteIndex];
                    const bit = (byte >> bitIndex) & 1;
                    
                    // 位图中1是黑色，0是白色
                    const value = bit === 1 ? 0 : 255;
                    
                    const pixelIndex = y * width + x;
                    const dataIndex = pixelIndex * 4;
                    imageData[dataIndex] = value;     // R
                    imageData[dataIndex + 1] = value; // G
                    imageData[dataIndex + 2] = value; // B
                    imageData[dataIndex + 3] = 255;   // A
                }
                
                pos += rowBytes;
            }
            
            return imageData;
        }
        
        // 解析二进制灰度图（用于P5）- 修复的部分
        function parseBinaryGrayscale(uint8Array, startPos, width, height, maxVal) {
            const imageData = new Uint8ClampedArray(width * height * 4);
            let pos = startPos;
            
            // 根据maxVal确定每个像素的字节数
            const bytesPerPixel = maxVal < 256 ? 1 : 2;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let pixelValue;
                    
                    if (bytesPerPixel === 1) {
                        // 单字节像素值
                        pixelValue = uint8Array[pos];
                        pos++;
                    } else {
                        // 双字节像素值（大端序）
                        pixelValue = (uint8Array[pos] << 8) | uint8Array[pos + 1];
                        pos += 2;
                    }
                    
                    // 缩放值到0-255范围
                    const scaledValue = Math.floor((pixelValue / maxVal) * 255);
                    
                    const pixelIndex = y * width + x;
                    const dataIndex = pixelIndex * 4;
                    imageData[dataIndex] = scaledValue;     // R
                    imageData[dataIndex + 1] = scaledValue; // G
                    imageData[dataIndex + 2] = scaledValue; // B
                    imageData[dataIndex + 3] = 255;         // A
                }
            }
            
            return imageData;
        }
        
        // 解析二进制RGB（用于P6）
        function parseBinaryRgb(uint8Array, startPos, width, height, maxVal) {
            const imageData = new Uint8ClampedArray(width * height * 4);
            let pos = startPos;
            
            // 根据maxVal确定每个颜色分量的字节数
            const bytesPerComponent = maxVal < 256 ? 1 : 2;
            const bytesPerPixel = bytesPerComponent * 3;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r, g, b;
                    
                    if (bytesPerComponent === 1) {
                        // 单字节颜色分量
                        r = uint8Array[pos];
                        g = uint8Array[pos + 1];
                        b = uint8Array[pos + 2];
                        pos += 3;
                    } else {
                        // 双字节颜色分量（大端序）
                        r = (uint8Array[pos] << 8) | uint8Array[pos + 1];
                        g = (uint8Array[pos + 2] << 8) | uint8Array[pos + 3];
                        b = (uint8Array[pos + 4] << 8) | uint8Array[pos + 5];
                        pos += 6;
                    }
                    
                    // 缩放值到0-255范围
                    const scaledR = Math.floor((r / maxVal) * 255);
                    const scaledG = Math.floor((g / maxVal) * 255);
                    const scaledB = Math.floor((b / maxVal) * 255);
                    
                    const pixelIndex = y * width + x;
                    const dataIndex = pixelIndex * 4;
                    imageData[dataIndex] = scaledR;         // R
                    imageData[dataIndex + 1] = scaledG;     // G
                    imageData[dataIndex + 2] = scaledB;     // B
                    imageData[dataIndex + 3] = 255;         // A
                }
            }
            
            return imageData;
        }
        
        // 从像素数据创建图像
        function createImageFromPixelData(pixelData, width, height) {
            // 创建临时canvas来绘制图像数据
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 创建ImageData对象
            const imageData = new ImageData(pixelData, width, height);
            tempCtx.putImageData(imageData, 0, 0);
            
            // 创建图像对象
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                resetView();
                drawImage();
                updateImageInfo();
            };
            
            img.onerror = function() {
                showError('创建图像时出错');
                showLoading(false);
            };
            
            img.src = tempCanvas.toDataURL();
        }
        
        // 加载标准图像格式(PNG, JPG, BMP等)
        function loadStandardImage(dataUrl) {
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                resetView();
                drawImage();
                updateImageInfo();
                updateStatus(`成功加载图像 (${img.width}×${img.height})`);
                showLoading(false);
            };
            
            img.onerror = function() {
                showError('无法加载图像文件。请确保文件是有效的图像格式。');
                showLoading(false);
            };
            
            img.src = dataUrl;
        }
        
        // 创建默认测试图像
        function createDefaultTestImage() {
            createTestImage('png');
        }
        
        // 创建测试图像
        function createTestImage(type) {
            updateStatus(`创建测试${type.toUpperCase()}图像...`);
            
            const width = 400;
            const height = 300;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 创建彩色测试图像
            // 背景渐变
            const gradient = tempCtx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#4cc9f0');
            gradient.addColorStop(0.5, '#4361ee');
            gradient.addColorStop(1, '#3a0ca3');
            tempCtx.fillStyle = gradient;
            tempCtx.fillRect(0, 0, width, height);
            
            // 绘制一些形状
            tempCtx.fillStyle = '#f72585';
            tempCtx.beginPath();
            tempCtx.arc(width * 0.3, height * 0.4, 40, 0, Math.PI * 2);
            tempCtx.fill();
            
            tempCtx.fillStyle = '#7209b7';
            tempCtx.beginPath();
            tempCtx.arc(width * 0.7, height * 0.6, 50, 0, Math.PI * 2);
            tempCtx.fill();
            
            tempCtx.fillStyle = '#4895ef';
            tempCtx.beginPath();
            tempCtx.rect(width * 0.2, height * 0.6, 80, 60);
            tempCtx.fill();
            
            // 添加文本
            tempCtx.fillStyle = '#ffffff';
            tempCtx.font = 'bold 24px Arial';
            tempCtx.textAlign = 'center';
            tempCtx.fillText('测试图像', width / 2, 50);
            
            // 添加一些像素级细节
            tempCtx.fillStyle = '#ffbe0b';
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * width);
                const y = Math.floor(Math.random() * height);
                tempCtx.fillRect(x, y, 2, 2);
            }
            
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                resetView();
                drawImage();
                updateImageInfo();
                updateStatus(`测试${type.toUpperCase()}图像已加载 (${width}×${height})`);
            };
            
            img.src = tempCanvas.toDataURL();
        }
        
        // 创建测试PGM ASCII图像
        function createTestPgmAscii() {
            updateStatus('创建测试PGM ASCII图像...');
            
            const width = 256;
            const height = 256;
            
            // 创建PGM ASCII格式内容
            let pgmContent = `P2\n# 测试PGM ASCII图像\n${width} ${height}\n255\n`;
            
            // 生成渐变灰度图像
            for (let y = 0; y < height; y++) {
                let row = '';
                for (let x = 0; x < width; x++) {
                    // 创建渐变效果
                    const value = Math.floor(
                        (Math.sin(x * 0.05) * 0.5 + 0.5) * 100 +
                        (Math.sin(y * 0.05) * 0.5 + 0.5) * 100 +
                        (Math.sin((x + y) * 0.03) * 0.5 + 0.5) * 55
                    );
                    row += Math.min(255, value) + ' ';
                }
                pgmContent += row.trim() + '\n';
            }
            
            // 转换为ArrayBuffer并解析
            const encoder = new TextEncoder();
            const arrayBuffer = encoder.encode(pgmContent).buffer;
            
            try {
                parseNetpbmFile(arrayBuffer, 'test_ascii.pgm');
            } catch (error) {
                showError(`创建测试PGM ASCII图像时出错: ${error.message}`);
                console.error(error);
            }
        }
        
        // 创建测试PGM二进制图像
        function createTestPgmBinary() {
            updateStatus('创建测试PGM二进制图像...');
            
            const width = 256;
            const height = 256;
            const maxVal = 255;
            
            // 创建二进制PGM内容
            const header = `P5\n# 测试PGM二进制图像\n${width} ${height}\n${maxVal}\n`;
            const encoder = new TextEncoder();
            const headerBytes = encoder.encode(header);
            
            // 创建像素数据
            const totalPixels = width * height;
            const pixelData = new Uint8Array(totalPixels);
            
            // 生成渐变灰度图像
            let index = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // 创建渐变效果
                    const value = Math.floor(
                        (Math.sin(x * 0.05) * 0.5 + 0.5) * 100 +
                        (Math.sin(y * 0.05) * 0.5 + 0.5) * 100 +
                        (Math.sin((x + y) * 0.03) * 0.5 + 0.5) * 55
                    );
                    pixelData[index] = Math.min(255, value);
                    index++;
                }
            }
            
            // 合并头部和像素数据
            const totalSize = headerBytes.length + pixelData.length;
            const arrayBuffer = new ArrayBuffer(totalSize);
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // 复制头部数据
            uint8Array.set(headerBytes, 0);
            
            // 复制像素数据
            uint8Array.set(pixelData, headerBytes.length);
            
            try {
                parseNetpbmFile(arrayBuffer, 'test_binary.pgm');
            } catch (error) {
                showError(`创建测试PGM二进制图像时出错: ${error.message}`);
                console.error(error);
            }
        }
        
        // 绘制图像
        function drawImage() {
            if (!currentImage) return;
            
            // 清除Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算绘制位置和大小
            const drawWidth = currentImage.width * scale;
            const drawHeight = currentImage.height * scale;
            
            // 确保图像在视图中
            const maxOffsetX = Math.max(0, drawWidth - canvas.width);
            const maxOffsetY = Math.max(0, drawHeight - canvas.height);
            
            offsetX = Math.min(maxOffsetX, Math.max(-maxOffsetX, offsetX));
            offsetY = Math.min(maxOffsetY, Math.max(-maxOffsetY, offsetY));
            
            // 保存图像平滑设置
            ctx.imageSmoothingEnabled = scale < 5;
            ctx.imageSmoothingQuality = 'high';
            
            // 绘制图像
            ctx.drawImage(currentImage, offsetX, offsetY, drawWidth, drawHeight);
            
            // 绘制像素网格（如果放大足够大且启用）
            if (showGrid && scale >= 8) {
                drawPixelGrid(drawWidth, drawHeight);
            }
            
            // 缓存图像数据用于像素拾取
            if (scale <= 3) {
                try {
                    lastImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                } catch (e) {
                    // 忽略获取图像数据时的错误
                }
            }
        }
        
        // 绘制像素网格
        function drawPixelGrid(drawWidth, drawHeight) {
            const gridSize = scale;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            
            // 垂直网格线
            for (let x = offsetX; x <= offsetX + drawWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + drawHeight);
                ctx.stroke();
            }
            
            // 水平网格线
            for (let y = offsetY; y <= offsetY + drawHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + drawWidth, y);
                ctx.stroke();
            }
        }
        
        // 处理鼠标滚轮（缩放）
        function handleWheel(e) {
            e.preventDefault();
            
            const zoomFactor = 0.1;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 计算鼠标在图像上的位置（相对于图像原点）
            const imageX = (mouseX - offsetX) / scale;
            const imageY = (mouseY - offsetY) / scale;
            
            // 调整缩放级别
            const delta = e.deltaY > 0 ? -zoomFactor : zoomFactor;
            const newScale = Math.max(0.5, Math.min(40, scale + delta));
            
            // 更新缩放滑块和显示
            scale = newScale;
            zoomSlider.value = scale;
            zoomValue.textContent = scale.toFixed(1);
            zoomDisplay.textContent = scale.toFixed(1) + 'x';
            
            // 调整偏移量，使缩放围绕鼠标位置
            offsetX = mouseX - imageX * scale;
            offsetY = mouseY - imageY * scale;
            
            drawImage();
        }
        
        // 处理鼠标按下（开始拖拽）
        function handleMouseDown(e) {
            if (!isPanMode || !currentImage) return;
            
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            offsetXStart = offsetX;
            offsetYStart = offsetY;
            
            canvas.style.cursor = 'grabbing';
        }
        
        // 处理鼠标移动
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 更新鼠标坐标显示
            if (currentImage) {
                const imageX = Math.floor((mouseX - offsetX) / scale);
                const imageY = Math.floor((mouseY - offsetY) / scale);
                
                // 检查坐标是否在图像范围内
                if (imageX >= 0 && imageX < currentImage.width && 
                    imageY >= 0 && imageY < currentImage.height) {
                    
                    coordDisplay.textContent = `X: ${imageX}, Y: ${imageY}`;
                    
                    // 获取像素颜色
                    let r = 0, g = 0, b = 0;
                    
                    try {
                        // 尝试从缓存的图像数据获取像素颜色
                        if (lastImageData) {
                            const dataX = Math.floor(mouseX);
                            const dataY = Math.floor(mouseY);
                            
                            if (dataX >= 0 && dataX < canvas.width && dataY >= 0 && dataY < canvas.height) {
                                const idx = (dataY * canvas.width + dataX) * 4;
                                r = lastImageData.data[idx];
                                g = lastImageData.data[idx + 1];
                                b = lastImageData.data[idx + 2];
                            }
                        }
                        
                        // 如果无法从缓存获取，尝试直接从Canvas获取
                        if (r === 0 && g === 0 && b === 0) {
                            const pixel = ctx.getImageData(mouseX, mouseY, 1, 1);
                            r = pixel.data[0];
                            g = pixel.data[1];
                            b = pixel.data[2];
                        }
                    } catch (e) {
                        // 如果无法获取，使用默认值
                        r = g = b = 0;
                    }
                    
                    rgbDisplay.textContent = `R: ${r}, G: ${g}, B: ${b}`;
                    colorPreview.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                } else {
                    coordDisplay.textContent = `X: -, Y: -`;
                    rgbDisplay.textContent = `R: -, G: -, B: -`;
                    colorPreview.style.backgroundColor = `transparent`;
                }
            }
            
            // 处理拖拽
            if (isDragging && isPanMode) {
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;
                
                offsetX = offsetXStart + deltaX;
                offsetY = offsetYStart + deltaY;
                
                drawImage();
            }
        }
        
        // 处理鼠标释放
        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            }
        }
        
        // 处理鼠标离开
        function handleMouseLeave() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'crosshair';
            }
        }
        
        // 重置视图
        function resetView() {
            if (!currentImage) return;
            
            // 重置缩放和位置
            scale = 1.0;
            offsetX = Math.max(0, (canvas.width - currentImage.width * scale) / 2);
            offsetY = Math.max(0, (canvas.height - currentImage.height * scale) / 2);
            
            // 更新UI
            zoomSlider.value = scale;
            zoomValue.textContent = scale.toFixed(1);
            zoomDisplay.textContent = scale.toFixed(1) + 'x';
            
            drawImage();
            updateStatus('视图已重置');
        }
        
        // 适应屏幕
        function fitToScreen() {
            if (!currentImage) return;
            
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // 计算适应屏幕的缩放比例
            const scaleX = containerWidth / currentImage.width;
            const scaleY = containerHeight / currentImage.height;
            scale = Math.min(scaleX, scaleY) * 0.95; // 留一些边距
            
            // 居中图像
            offsetX = (containerWidth - currentImage.width * scale) / 2;
            offsetY = (containerHeight - currentImage.height * scale) / 2;
            
            // 更新UI
            zoomSlider.value = scale;
            zoomValue.textContent = scale.toFixed(2);
            zoomDisplay.textContent = scale.toFixed(2) + 'x';
            
            drawImage();
            updateStatus('图像已适应屏幕');
        }
        
        // 更新图像信息
        function updateImageInfo() {
            if (currentImage) {
                sizeDisplay.textContent = `${currentImage.width} × ${currentImage.height} 像素`;
            }
        }
        
        // 更新状态消息
        function updateStatus(message) {
            statusMessage.textContent = message;
        }
        
        // 显示错误消息
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }
        
        // 清除错误消息
        function clearError() {
            errorMessage.style.display = 'none';
            errorMessage.textContent = '';
        }
        
        // 显示/隐藏加载指示器
        function showLoading(show) {
            loadingIndicator.style.display = show ? 'block' : 'none';
        }
        
        // 初始化应用
        init();
    </script>
</body>
</html>